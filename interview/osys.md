# 内核

操作系统的核心程序，提供核心功能

内核态：运行内核程序，可以访问所有内存

用户态：运行应用程序，有内存空间权限限制

内核态和用户态切换：中断

# 程序 & 进程 & 线程

**程序**：程序是静态的可执行文件，一系列指令合集

**进程**

进程：进程实体的运行过程，系统进行资源分配和调度的独立单位

进程实体：包含程序段、相关数据段和进程控制块 PCB

进程控制块：进程描述符 PID、用户描述符 UID、进程状态、进程优先级、资源分配信息 (IO 设备信息、代码段、数据段指针)、处理器信息 (寄存器上下文状态)

**线程**

线程： CPU 资源分配和调度的基本单位，线程也具有就绪、阻塞、运行三种状态

线程控制块：包含线程 ID、程序计数器 PC，寄存器集合（各线程不共享）和堆栈（部分不共享）组成

用户级线程：线程管理（线程的创建、撤销和切换等）的所有工作都由应用程序完成，内核意识不到线程的存在。用户级线程切换线程上下文开销更低。

内核级线程：线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个内核级线程的编程接口，内核为进程及其内部的每个线程维护上下文信息，调度也在内核基于线程架构的基础上完成。内核级线程并发性更好。

混合方式：线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行。应用程序中的多个用户级线程被映射到一些（小于等于用户级线程数）内核级线程上。

**并发 (Concurrence) & 并行**

并发：指多个事件在同一段时间内发生，宏观上有多道程序同时执行，每个时刻，单处理机环境下微观上仍是分时交替执行的，操作系统的并发性通过分时得以实现

并行：同一时刻多程序运行，需要多处理器

**进程上下文 & 线程上下文**

CPU 资源从一个进程分配给另一个进程的机制，先存储当前进程的状态 (包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态到寄存器。

进程上下文切换内存资源，IO 资源，以及寄存器资源。

线程上下文切换，如果是同一进程，只需要切换私有堆栈数据和寄存器。

**进程状态**

![](https://cdn.staticaly.com/gh/NosignaL994/Assets@main/images/os-process-status.74cy66ydb6s0.webp)

运行态：进程在处理器上运行

就绪态：进程获得了除处理器外的一切所需资源，等待处理器

阻塞态：进程正在等待除处理器之外的资源可用

创建态：申请空 PCB，填入一些控制和管理进程的信息，然后由系统为该进程分配运行时所需的资源后，进入就绪态

结束态：进程正常结束或因其他原因中断退出运行，处理资源释放和回收等

**僵尸进程 & 孤儿进程**

僵尸进程：已完成且处于终止态，但仍存在于进程表中的进程。僵尸进程一般发生在父子进程中，子进程退出时进程描述符不会释放，只有当父进程通过 `wait() | waitpid()` 获取子进程信息后才会被释放。

孤儿进程：父进程退出，而其子进程还在运行，则子进程称为孤儿进程。孤儿进程会被 Init 进程（进程 ID 为 1）收养，并有 Init 进程 完成其状态收集工作，因此不会对系统造成危害

### 进程调度

**先来先服务**

**短作业优先**：按估计运行时间最短的顺序进行调度，长时间的进程可能会饿死

**优先级调度**：为进程分配优先级，按优先级进行调度，优先级可以基于预计运行时间、运行时间和等待时间进行计算。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

**时间片轮转**：一个进程执行一个时间片，后被剥夺处理器，放入进程队尾

**多级反馈队列**：设置多个队列，并为各个队列赋予不同的优先级。越高优先级队列的运行时间片越小。按照先来先服务，若该进程在一个时间片内尚未完成，便将进程转入下一级队列的末尾

### 进程通信

**管道**

管道是一个半双工的进程通信共享文件。匿名管道：用于父子进程之间的通信，存在于内存中；命名管道：非亲缘进程之间的通信，以一种特殊文件的形式存在于文件系统中

管道由内核支持，经过内核态，由内核控制互斥访问。

**消息队列**

进程通过系统提供的发送消息和接收消息两个原语进行以格式化的信息为单位的数据交换。
消息可以发送到接收进程的消息缓冲队列，也可以发送到某个中间实体作为消息队列。
接收进程通过接收消息原语获取信息。

**共享内存 & 信号量**

设置一块可直接访问的共享空间，通过对这片共享空间进行读写操作实现进程通信。
共享内存可以看作临界资源，通过信号量控制进程同步互斥访问

共享内存不会涉及内核态的拷贝

**信号量 PV 操作** 只能传递信号量，不能传递复杂信息，一般用于实现进程同步

**Socket** 用于不同主机的进程通信

### 同步 & 互斥

同步：直接制约关系，进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。

信号量实现同步：在“前操作”之后执行 V(S)，在“后操作”之前执行 P(S)，前驱关系的实现与同步类似，多设置几个信号量即可

互斥：间接制约关系，当一个进程占有临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许访问此临界资源

信号量实现互斥：进入区执行 P(S)，结束区执行 V(S)，除临界区外，中间不要有冗余的代码

### 死锁

进程互相等待资源，导致无法向前推进

产生条件：互斥条件（临界资源）、不剥夺条件、请求并保持条件（持有资源，提出新的资源请求出现阻塞而不释放）、循环等待条件（存在一种进程资源的循环等待链）

预防死锁：破坏死锁的产生条件。高优先级剥夺低优先级资源、阻塞释放持有资源

避免死锁：银行家算法（主要思想：保证剩余资源能够依次满足进程的最大需求并释放已持有资源，以保持安全状态，非安全状态并非一定就是死锁状态，但只要处于安全状态，就能避免死锁）

死锁检测：深度优先遍历有向图，如果访问到已访问的节点，则存在循环，即存在死锁。

死锁恢复：资源剥夺法（挂起某些死锁进程，并抢占其资源）、撤销进程法（强制撤销部分甚至全部死锁进程并剥夺这些进程的资源）、进程回退法（让一个或多个进程回退到足以回避死锁的地步，进程回退时资源释放资源。要求系统保持进程历史信息，设置还原点）

### 活锁 & 饥饿锁

活锁：进程或线程请求多个资源时，因为程序避免死锁的逻辑设计不当，导致互相谦让资源，导致出现循环请求释放资源，程序无法继续的情况。

饥饿锁：资源饥饿，某个线程一直等不到它所需要的资源，从而无法向前推进。

### 线程进程同步的区别

进程之间地址空间不同，不能感知对方的存在，同步时需要将锁放在多进程共享的空间。而线程之间共享同一地址空间，同步时把锁放在所属的同一进程空间即可。

# 内存管理

#### 连续 & 非连续

非连续的内存分配允许程序分散地装入内存，非连续包含分段、分页和段页式

#### 分段

按照用户进程中的自然段（代码段、数据段、堆栈段等）划分逻辑空间。

段表中记录段号对应的段物理始址和长度，通过段号和段内偏移量计算出物理地址

#### 分页

把内存划分为大小相等且固定的块，作为主存的基本单位。进程也以块为单位逐个申请内存中的块空间。块的大小相对分区分配方法中的分区小很多，产生的内部碎片更小

访问页表，从中找到指定的物理页号，加上页内偏移得到实际物理地址，然后根据第一次得到的物理地址访问内存取出数据

快表：增设一个具有并行查找能力的高速缓存存储器（集成在 CPU 内部，速度介于内存与寄存器之间），用于缓存页表项，加快地址变换速度，成为快表（TLB，Translation Lookaside Buffer），内存的中的页表称为慢表。TLB 中只保存页表项的副本。

#### 段页式

段页式管理中，地址空间首先被分成若干逻辑段，每个段再分成若干大小固定的页。内存空间分成若干和页面大小相同的存储块，对内存的分配以块为单位。

逻辑地址分为段号、页号和页内偏移量。

地址转化：每个进程建立一张段表，每个分段有一张页表。段表项中包括段号、页表长度和页表始址，页表项中至少包括页号和块号。系统中同样要用段表寄存器，指出作业的段表始址和段表长度

#### 页面置换算法

**先进先出置换算法（FIFO）**

优先淘汰最早进入内存的页面，即在内存中驻留时间最久的页面。该算法实现简单，只需把调入内存的页面根据先后次序链接成队列，设置一个指针总指向最早的页面。但该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。

FIFO 算法还会产生所分配的物理块数增大而页故障数不减反增的异常现象，称为 Belady 异常。只有 FIFO 算法可能出现这种异常。

**最近最久未使用置换算法（LRU）**

利用页面的访问字段，来记录页面自上次被访问以来所经历的时间，选择现有页面中之最大的予以淘汰。

LRU 算法的性能较好，但需要寄存器和栈的硬件支持，且开销较大，要对页面基于访问字段进行排序。LRU 是堆栈类的算法，不会出现 Belady 异常

**时钟置换算法（CLOCK | NRU）**

LRU 算法性能接近于 OPT 算法，但实现起来比较困难，且开销大。CLOCK 算法的变体可以用比较小的开销接近 LRU 算法的性能。

给每页关联一个使用位。当某页首次装入主存时或该页被访问到时，其使用位被置为 1。页面以循环链表的方式组织起来，当需要替换一页时，扫描这个循环链表，查找使用位数为 0 的一帧，进行替换。每当遇到一个使用位为 1 的帧时，将其使用位重新置为 0，该算法又称最近未用（Not Recently Used，NRU）算法。

**最不常用算法（LFU）**

双哈希表 & 双向链表，使用频率为键映射使用频率的双向链表的哈希表，同时建立以 key 为键映射链表节点的哈希表。找出使用频率最低的，如果有相同的，则根据最近访问时间淘汰。使用堆优化。

# 文件

目录建立文件名和索引节点（inode）指针的映射，索引节点包含文件相关的信息：类型（普通文件、目录文件等）、存取权限、物理地址、字节长度、链接计数。

**硬链接 & 软链接**

基于索引结点的共享方式（硬链接）

将共享文件或子目录链接到两个或多个用户的目录中，索引结点中应有一个链接计数，记录链接到本索引结点（即文件）的用户目录项数目。

用符号链实现的文件共享（软链接）

创建一个 LINK 类型的新文件，文件中只包含需共享文件的路径，通过符号链访问文件时，需要根据路径名逐个查找目录，访问时可能要多次读盘，增大了访问文件的开销。

软链接可以跨文件系统访问文件

# IO

#### 零拷贝

只在内核态完成两个 IO 设备的数据交换，避免经过用户态的应用程序，减少内核态和用户态的上下文切换的开销

#### 阻塞 IO | 非阻塞 IO

阻塞 IO 模型：进程或线程在请求 IO 数据时阻塞等待内核读入 IO 数据，在从缓冲区读入进程（一次阻塞调用）

非阻塞 IO 模型：请求不阻塞等待，返回并在后续轮询检查 IO 数据是否读入内核缓冲区，确认读入后在阻塞进程从缓冲区拷贝（多次非阻塞调用 + 一次阻塞调用）

#### 同步 IO | 异步 IO

同步 IO：等待内核进程读入 IO 设备数据，用户进程在进行拷贝，明确的先后协调

异步 IO：内核进程直接读入并复制进入用户进程，内核进程和用户进程的运行没有先后的协调
